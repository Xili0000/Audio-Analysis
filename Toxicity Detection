# === Updated Version: mp3totexttocla.py ===
# Now translates (if needed) and detects toxicity in ENGLISH instead of SPANISH

import os
import sys
from pydub import AudioSegment
from google.cloud import speech
from google.cloud import storage
import nltk
import vertexai
from vertexai.generative_models import GenerativeModel, SafetySetting
from googleapiclient import discovery
import json
from google import genai
from google.genai import types

# Set Google Cloud credentials
os.environ["GOOGLE_APPLICATION_CREDENTIALS"] = "thermal-origin-454105-s5-c6291f413f44.json"

# API Key (may not be used directly)
API_KEY = 'AIzaSyDGwQzJDQe_lJv7YnhnM3JFjQDA0HRZUf8'

# Download NLTK data if needed
# nltk.download('punkt')

# Global configuration
generation_config = {
    "max_output_tokens": 8192,
    "temperature": 1,
    "top_p": 0.95,
    "seed": 0,
}

safety_settings = [
    SafetySetting(
        category=SafetySetting.HarmCategory.HARM_CATEGORY_HATE_SPEECH,
        threshold=SafetySetting.HarmBlockThreshold.OFF
    ),
    SafetySetting(
        category=SafetySetting.HarmCategory.HARM_CATEGORY_DEROGATORY,
        threshold=SafetySetting.HarmBlockThreshold.OFF
    ),
]

# Initialize Vertex AI
vertexai.init(project="thermal-origin-454105", location="us-central1")
model = GenerativeModel("gemini-1.5-pro-preview-0409")

# Function to upload audio to GCS
def upload_to_bucket(bucket_name, source_file_name, destination_blob_name):
    storage_client = storage.Client()
    bucket = storage_client.bucket(bucket_name)
    blob = bucket.blob(destination_blob_name)
    blob.upload_from_filename(source_file_name)
    print(f"File {source_file_name} uploaded to {destination_blob_name}.")

# Function to transcribe audio file
def transcribe_audio(bucket_name, audio_blob_path, language_code="en-US"):
    client = speech.SpeechClient()

    audio = speech.RecognitionAudio(uri=f"gs://{bucket_name}/{audio_blob_path}")
    config = speech.RecognitionConfig(
        encoding=speech.RecognitionConfig.AudioEncoding.LINEAR16,
        sample_rate_hertz=16000,
        language_code=language_code,
    )

    response = client.recognize(config=config, audio=audio)

    transcript = ""
    for result in response.results:
        transcript += result.alternatives[0].transcript + "\n"
    return transcript

# Function to split text into sentences
def split_into_sentences(text):
    return nltk.sent_tokenize(text)

# Function to translate text into English (identity function now)
def translate_to_english(text):
    # Since the source language is assumed English after STT, no actual translation needed
    return text

# Function to detect toxicity
def detect_toxicity(sentence):
    prompt_text = f"""
You are a toxicity detection AI.
Given a sentence, classify it as 'toxic' or 'non-toxic'.

Sentence:
"{sentence}"

Output only one word: 'toxic' or 'non-toxic'.
"""

    responses = model.generate_content(prompt_text, generation_config=generation_config, safety_settings=safety_settings)
    return responses.text.strip()

# Main processing function
def process_mp3(mp3_local_path, bucket_name):
    # Convert mp3 to wav
    audio = AudioSegment.from_mp3(mp3_local_path)
    audio = audio.set_frame_rate(16000).set_channels(1)
    wav_path = mp3_local_path.replace(".mp3", ".wav")
    audio.export(wav_path, format="wav")

    # Upload to GCS
    blob_name = os.path.basename(wav_path)
    upload_to_bucket(bucket_name, wav_path, blob_name)

    # Transcribe
    transcription = transcribe_audio(bucket_name, blob_name)

    # Translate (identity for English)
    translated_text = translate_to_english(transcription)

    # Split into sentences
    sentences = split_into_sentences(translated_text)

    # Detect toxicity per sentence
    for idx, sentence in enumerate(sentences):
        result = detect_toxicity(sentence)
        print(f"Sentence {idx+1}: {sentence}\nPrediction: {result}\n")

if __name__ == "__main__":
    # Example usage
    mp3_path = "/content/sample_audio.mp3"  # Replace with your MP3 path
    bucket_name = "your-bucket-name"  # Replace with your GCP bucket name
    process_mp3(mp3_path, bucket_name)
